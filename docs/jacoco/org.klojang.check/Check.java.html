<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Check.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Klojang Check</a> &gt; <a href="index.source.html" class="el_package">org.klojang.check</a> &gt; <span class="el_source">Check.java</span></div><h1>Check.java</h1><pre class="source lang-java linenums">package org.klojang.check;

import org.klojang.check.x.msg.CustomMsgFormatter;

import java.util.Arrays;
import java.util.List;
import java.util.function.Function;
import java.util.function.Supplier;

import static org.klojang.check.x.msg.CustomMsgFormatter.formatSimple;

/**
 * The central class of this Java module. All checks start out here. The
 * {@code Check} class provides static factory methods for {@link IntCheck} and
 * {@link ObjectCheck} instances, which do the actual orchestration of the checks to
 * be executed. The {@code Check} class contains a few validation methods itself,
 * like {@link #fromTo(int, int, int) Check.fromTo()} and
 * {@link #offsetLength(int, int, int) Check.offsetLength()}. These stand somewhat
 * apart from the rest of the Klojang Check. They are included for convenience and
 * for optimal performance.
 *
 * &lt;p&gt;See the &lt;a href=&quot;../../../module-summary.html&quot;&gt;module summary&lt;/a&gt; for a
 * detailed description of Defensive Programming using Klojang Check.
 *
 * @author Ayco Holleman
 */
public final class Check {

<span class="nc" id="L29">  private Check() {</span>
<span class="nc" id="L30">    throw new UnsupportedOperationException();</span>
  }

  private static NullPointerException argumentMustNotBeNull() {
<span class="fc" id="L34">    return new NullPointerException(&quot;argument must not be null&quot;);</span>
  }

  private static NullPointerException argumentMustNotBeNull(String tag) {
<span class="fc" id="L38">    return new NullPointerException(tag + &quot; must not be null&quot;);</span>
  }

<span class="fc" id="L41">  private static final Function&lt;String, IllegalArgumentException&gt; DEF_EXC_FACTORY =</span>
      CommonExceptions.ARGUMENT;

  /**
   * Static factory method. Returns an {@link IntCheck} instance suitable for testing
   * {@code int} values.
   *
   * @param value the value to be validated
   * @return an {@code IntCheck} instance suitable for testing {@code int} values
   */
  public static IntCheck&lt;IllegalArgumentException&gt; that(int value) {
<span class="fc" id="L52">    return new IntCheck&lt;&gt;(value, null, DEF_EXC_FACTORY);</span>
  }

  /**
   * Static factory method. Returns an {@link ObjectCheck} instance suitable for
   * validating values of type {@code &lt;T&gt;}.
   *
   * @param &lt;T&gt; the type of the value to be validated
   * @param value the value to be validated
   * @return an {@code ObjectCheck} instance suitable for validating values of type
   *     {@code &lt;T&gt;}.
   */
  public static &lt;T&gt; ObjectCheck&lt;T, IllegalArgumentException&gt; that(T value) {
<span class="fc" id="L65">    return new ObjectCheck&lt;&gt;(value, null, DEF_EXC_FACTORY);</span>
  }

  /**
   * Static factory method. Returns an {@link IntCheck} instance suitable for
   * validating {@code int} values.
   *
   * @param value the value to be validated
   * @param tag a descriptive name for the value (in case the value is a method
   *     argument probably something close to the parameter name)
   * @return an {@code IntCheck} instance suitable for testing {@code int} values
   */
  public static IntCheck&lt;IllegalArgumentException&gt; that(int value, String tag) {
<span class="fc" id="L78">    return new IntCheck&lt;&gt;(value, tag, DEF_EXC_FACTORY);</span>
  }

  /**
   * Static factory method. Returns an {@link ObjectCheck} instance suitable for
   * validating values of type {@code &lt;T&gt;}.
   *
   * @param &lt;T&gt; the type of the value to be validated
   * @param value the value to be validated
   * @param tag a descriptive name for the value (in case the value is a method
   *     argument probably something close to the parameter name)
   * @return an {@code ObjectCheck} instance suitable for validating values of type
   *     {@code &lt;T&gt;}.
   */
  public static &lt;T&gt; ObjectCheck&lt;T, IllegalArgumentException&gt; that(T value,
      String tag) {
<span class="fc" id="L94">    return new ObjectCheck&lt;&gt;(value, tag, DEF_EXC_FACTORY);</span>
  }

  /**
   * Static factory method. Returns an {@link ObjectCheck} instance suitable for
   * validating values of type {@code &lt;T&gt;}. The argument will have already passed the
   * {@linkplain CommonChecks#notNull() null test}. Note that an
   * {@code IllegalArgumentException} thrown the specified value fails any of the
   * subsequently specified checks, but if the argument was {@code null}, a
   * {@code NullPointerException} will be thrown.
   *
   * @param &lt;T&gt; the type of the value to be validated
   * @param value the value to be validated
   * @return an {@code ObjectCheck} instance suitable for validating values of type
   *     {@code &lt;T&gt;}.
   * @throws NullPointerException if the argument is {@code null}
   */
  public static &lt;T&gt; ObjectCheck&lt;T, IllegalArgumentException&gt; notNull(T value)
      throws NullPointerException {
<span class="fc bfc" id="L113" title="All 2 branches covered.">    if (value != null) {</span>
<span class="fc" id="L114">      return new ObjectCheck&lt;&gt;(value, null, DEF_EXC_FACTORY);</span>
    }
<span class="fc" id="L116">    throw argumentMustNotBeNull();</span>
  }

  /**
   * Static factory method. Returns an {@link ObjectCheck} instance suitable for
   * validating values of type {@code &lt;T&gt;}. The argument will have already passed the
   * {@linkplain CommonChecks#notNull() null test}. Note that an
   * {@code IllegalArgumentException} thrown the specified value fails any of the
   * subsequently specified checks, but if the argument was {@code null}, a
   * {@code NullPointerException} will be thrown.
   *
   * @param &lt;T&gt; the type of the value to be validated
   * @param value the value to be validated
   * @param tag a descriptive name for the value (in case the value is a method
   *     argument probably something close to the parameter name)
   * @return an {@code ObjectCheck} instance suitable for validating values of type
   *     {@code &lt;T&gt;}.
   * @throws NullPointerException if the argument is {@code null}
   */
  public static &lt;T&gt; ObjectCheck&lt;T, IllegalArgumentException&gt; notNull(T value,
      String tag)
      throws IllegalArgumentException {
<span class="fc bfc" id="L138" title="All 2 branches covered.">    if (value != null) {</span>
<span class="fc" id="L139">      return new ObjectCheck&lt;&gt;(value, tag, DEF_EXC_FACTORY);</span>
    }
<span class="fc" id="L141">    throw argumentMustNotBeNull(tag);</span>
  }

  /**
   * Static factory method. Returns an {@link IntCheck} instance suitable for
   * validating {@code int} values. If the value fails any of the tests passed to the
   * {@code IntCheck} instance, the exception produced by the provided exception
   * factory is thrown.
   *
   * @param excFactory a function that will produce the exception if the value
   *     fails to pass a test. The function will be pass the exception message and
   *     must return the exception to be thrown
   * @param value the value to be validated
   * @param &lt;X&gt; the type of {@code Exception} thrown if the value fails to pass a
   *     test
   * @return an {@code IntCheck} instance suitable for testing {@code int} values
   */
  public static &lt;X extends Exception&gt; IntCheck&lt;X&gt; on(Function&lt;String, X&gt; excFactory,
      int value) {
<span class="fc" id="L160">    return new IntCheck&lt;&gt;(value, null, excFactory);</span>
  }

  /**
   * Static factory method. Returns an {@code ObjectCheck} instance suitable for
   * validating values of type {@code &lt;T&gt;}. If the value fails any of the tests
   * passed to the {@code ObjectCheck} instance, the exception produced by the
   * provided exception factory is thrown.
   *
   * @param &lt;T&gt; the type of the value to be validated
   * @param &lt;X&gt; the type of {@code Exception} thrown if the value fails to pass a
   *     test
   * @param excFactory a function that will produce the exception if the value
   *     fails to pass a test. The function will be pass the exception message and
   *     must return the exception to be thrown
   * @param value the value to be validated
   * @return an {@code ObjectCheck} instance suitable for validating values of type
   *     {@code &lt;T&gt;}.
   */
  public static &lt;T, X extends Exception&gt; ObjectCheck&lt;T, X&gt; on(
      Function&lt;String, X&gt; excFactory, T value) {
<span class="fc" id="L181">    return new ObjectCheck&lt;&gt;(value, null, excFactory);</span>
  }

  /**
   * Static factory method. Returns an {@link IntCheck} instance suitable for
   * validating {@code int} values. If the value fails any of the tests passed to the
   * {@code IntCheck} instance, the exception produced by the provided exception
   * factory is thrown.
   *
   * @param excFactory a function that will produce the exception if the value
   *     fails to pass a test. The function will be pass the exception message and
   *     must return the exception to be thrown
   * @param value the value to be validated
   * @param tag a descriptive name for the value (in case the value is a method
   *     argument probably something close to the parameter name)
   * @param &lt;X&gt; the type of {@code Exception} thrown if the value fails to pass a
   *     test
   * @return an {@code IntCheck} instance suitable for testing {@code int} values
   */
  public static &lt;X extends Exception&gt; IntCheck&lt;X&gt; on(
      Function&lt;String, X&gt; excFactory, int value, String tag) {
<span class="fc" id="L202">    return new IntCheck&lt;&gt;(value, tag, excFactory);</span>
  }

  /**
   * Static factory method. Returns a new {@code Check} instance suitable for testing
   * the provided argument.
   *
   * @param &lt;T&gt; the type of the value to be validated
   * @param &lt;X&gt; the type of {@code Exception} thrown if the value fails to pass a
   *     test
   * @param excFactory a function that will produce the exception if the value
   *     fails to pass a test. The function will be pass the exception message and
   *     must return the exception to be thrown
   * @param value the value to be validated
   * @param tag a descriptive name for the value (in case the value is a method
   *     argument probably something close to the parameter name)
   * @return an {@code ObjectCheck} instance suitable for validating values of type
   *     {@code &lt;T&gt;}.
   */
  public static &lt;T, X extends Exception&gt; ObjectCheck&lt;T, X&gt; on(
      Function&lt;String, X&gt; excFactory, T value, String tag) {
<span class="fc" id="L223">    return new ObjectCheck&lt;&gt;(value, tag, excFactory);</span>
  }

  /**
   * All-in-one check for the specified array, offset and length. Verifies that
   * {@code offset} and {@code length} are valid, given the length of the specified
   * array. More precisely:
   *
   * &lt;ol&gt;
   *   &lt;li&gt;throws an {@code IllegalArgumentException} if the array is {@code null}.
   *   &lt;li&gt;throws an {@code IndexOutOfBoundsException} if {@code offset} or {@code length} is less than zero
   *   &lt;li&gt;throws an {@code IndexOutOfBoundsException} if {@code offset+length} is greater than the length of the array
   * &lt;/ol&gt;
   *
   * &lt;i&gt;NB The {@code fromTo} and {@code offsetLength} checks stand somewhat apart from the
   * rest of the check framework. They happen through &quot;ordinary&quot; static utility method and they
   * test multiple things at once. They are included for convenience and speed.&lt;/i&gt;
   *
   * @param array the array
   * @param offset the offset within the array
   * @param length the length of the segment
   * @see #offsetLength(int, int, int)
   * @see java.io.OutputStream#write(byte[], int, int)
   * @see java.io.InputStream#read(byte[], int, int)
   */
  public static void offsetLength(byte[] array, int offset, int length) {
<span class="fc bfc" id="L249" title="All 2 branches covered.">    if (array == null) {</span>
<span class="fc" id="L250">      throw argumentMustNotBeNull(&quot;array&quot;);</span>
    }
<span class="fc bfc" id="L252" title="All 4 branches covered.">    if ((offset | length) &lt; 0 || offset + length &gt; array.length) {</span>
<span class="fc" id="L253">      throw new IndexOutOfBoundsException();</span>
    }
<span class="fc" id="L255">  }</span>

  /**
   * All-in-one check for the provided size, offset and length. Verifies that
   * {@code offset} and {@code length} are valid, given tan array or array-like
   * object with the specified size.
   *
   * &lt;ol&gt;
   *   &lt;li&gt;throws an {@code IndexOutOfBoundsException} if {@code size} or {@code offset} or {@code length} is less than zero
   *   &lt;li&gt;throws an {@code IndexOutOfBoundsException} if {@code offset+length} is greater than the length of the array
   * &lt;/ol&gt;
   *
   * &lt;i&gt;NB The {@code fromTo} and {@code offsetLength} checks stand somewhat apart from the
   * rest of the check framework. They happen through &quot;ordinary&quot; static utility method and they
   * test multiple things at once. They are included for convenience and speed.&lt;/i&gt;
   *
   * @param size the length/size of the array or array-like object
   * @param offset the offset
   * @param length the length of the segment
   */
  public static void offsetLength(int size, int offset, int length) {
<span class="fc bfc" id="L276" title="All 4 branches covered.">    if ((size | offset | length) &lt; 0 || size &lt; offset + length) {</span>
<span class="fc" id="L277">      throw new IndexOutOfBoundsException();</span>
    }
<span class="fc" id="L279">  }</span>

  /**
   * An all-in-one check for the provided list, from-index and to-index. Verifies
   * that the from-index and to-index valid list indices. More precisely:
   *
   * &lt;ol&gt;
   *   &lt;li&gt;Throws a {@code NullPointerException} if the list is {@code null}
   *   &lt;li&gt;Throws an {@code IndexOutOfBoundsException} if {@code fromIndex} or {@code toIndex} is less than zero
   *   &lt;li&gt;Throws an {@code IndexOutOfBoundsException} if {@code toIndex} is less than {@code fromIndex}
   *   &lt;li&gt;Throws an {@code IndexOutOfBoundsException} if {@code toIndex} is greater than the size of the list
   * &lt;/ol&gt;
   *
   * &lt;i&gt;NB The {@code fromTo()} and {@code offsetLength()} checks stand somewhat
   * apart from the rest of the check framework. They happen through &quot;ordinary&quot;
   * static utility method and they test multiple things at once. They are included
   * for convenience and speed.&lt;/i&gt;
   *
   * @param list the list
   * @param fromIndex the start index of the sublist
   * @param toIndex the end index of the sublist
   * @return the {@code size} of the sublist
   * @see #fromTo(int, int, int)
   * @see List#subList(int, int)
   */
  public static int fromTo(List&lt;?&gt; list, int fromIndex, int toIndex) {
<span class="fc bfc" id="L305" title="All 2 branches covered.">    if (list == null) {</span>
<span class="fc" id="L306">      throw argumentMustNotBeNull(&quot;list&quot;);</span>
    }
<span class="fc bfc" id="L308" title="All 6 branches covered.">    if ((fromIndex | toIndex) &lt; 0 || toIndex &lt; fromIndex || list.size() &lt; toIndex) {</span>
<span class="fc" id="L309">      throw new IndexOutOfBoundsException();</span>
    }
<span class="fc" id="L311">    return toIndex - fromIndex;</span>
  }

  /**
   * An all-in-one check for the provided array, from-index and to-index. Verifies
   * that the from-index and to-index valid array indices. More precisely:
   *
   * &lt;ol&gt;
   *   &lt;li&gt;Throws a {@code NullPointerException} if the array is {@code null}
   *   &lt;li&gt;Throws an {@code IndexOutOfBoundsException} if {@code fromIndex} or {@code toIndex} is less than zero
   *   &lt;li&gt;Throws an {@code IndexOutOfBoundsException} if {@code toIndex} is less than {@code fromIndex}
   *   &lt;li&gt;Throws an {@code IndexOutOfBoundsException} if {@code toIndex} is greater than the size of the list
   * &lt;/ol&gt;
   *
   * @param array the array
   * @param fromIndex the start index of the array segment
   * @param toIndex the end index of the array segment
   * @param &lt;T&gt; the type of the array elements
   * @return the {@code length} of the array segment
   * @see #fromTo(int, int, int)
   * @see Arrays#copyOfRange(Object[], int, int)
   */
  public static &lt;T&gt; int fromTo(T[] array, int fromIndex, int toIndex) {
<span class="fc bfc" id="L334" title="All 2 branches covered.">    if (array == null) {</span>
<span class="fc" id="L335">      throw argumentMustNotBeNull(&quot;array&quot;);</span>
    }
<span class="fc bfc" id="L337" title="All 6 branches covered.">    if ((fromIndex | toIndex) &lt; 0 || toIndex &lt; fromIndex || array.length &lt; toIndex) {</span>
<span class="fc" id="L338">      throw new IndexOutOfBoundsException();</span>
    }
<span class="fc" id="L340">    return toIndex - fromIndex;</span>
  }

  /**
   * An all-in-one check for the provided string, from-index and to-index. Verifies
   * that the from-index and to-index valid string indices. More precisely:
   *
   * &lt;ol&gt;
   *   &lt;li&gt;Throws a {@code NullPointerException} if the string is {@code null}
   *   &lt;li&gt;Throws an {@code IndexOutOfBoundsException} if {@code fromIndex} or {@code toIndex} is less than zero
   *   &lt;li&gt;Throws an {@code IndexOutOfBoundsException} if {@code toIndex} is less than {@code fromIndex}
   *   &lt;li&gt;Throws an {@code IndexOutOfBoundsException} if {@code toIndex} is greater than the size of the list
   * &lt;/ol&gt;
   *
   * @param string the string
   * @param fromIndex the start index of the substring
   * @param toIndex the end index of the substring
   * @return the {@code length} of the substring
   * @see #fromTo(int, int, int)
   * @see String#substring(int, int)
   */
  public static int fromTo(String string, int fromIndex, int toIndex) {
<span class="fc bfc" id="L362" title="All 2 branches covered.">    if (string == null) {</span>
<span class="fc" id="L363">      throw argumentMustNotBeNull(&quot;string&quot;);</span>
    }
<span class="fc bfc" id="L365" title="All 4 branches covered.">    if ((fromIndex | toIndex) &lt; 0</span>
        || toIndex &lt; fromIndex
<span class="fc bfc" id="L367" title="All 2 branches covered.">        || string.length() &lt; toIndex) {</span>
<span class="fc" id="L368">      throw new IndexOutOfBoundsException();</span>
    }
<span class="fc" id="L370">    return toIndex - fromIndex;</span>
  }

  /**
   * An all-in-one check for the provided size/length (supposedly of an array or
   * array-like object), from-index and to-index. Verifies that the from-index and
   * to-index valid string indices, given the specified size/length. More precisely:
   *
   * &lt;ol&gt;
   *   &lt;li&gt;Throws an {@code IndexOutOfBoundsException} if {@code size} or {@code fromIndex} or {@code toIndex} is less than zero
   *   &lt;li&gt;Throws an {@code IndexOutOfBoundsException} if {@code toIndex} is less than {@code fromIndex}
   *   &lt;li&gt;Throws an {@code IndexOutOfBoundsException} if {@code toIndex} is greater than the size of the list
   * &lt;/ol&gt;
   *
   * &lt;i&gt;NB The {@code fromTo} and {@code offsetLength} checks stand somewhat apart from the
   * rest of the check framework. They happen through &quot;ordinary&quot; static utility method and they
   * test multiple things at once. They are included for convenience and speed.&lt;/i&gt;
   *
   * @param size the size (or length) of the array, string, list, etc.
   * @param fromIndex the start index of the segment
   * @param toIndex the end index of the segment
   * @return the {@code length} of the segment
   */
  public static int fromTo(int size, int fromIndex, int toIndex) {
<span class="pc bpc" id="L394" title="2 of 6 branches missed.">    if ((size | fromIndex | toIndex) &lt; 0 || toIndex &lt; fromIndex || size &lt; toIndex) {</span>
<span class="fc" id="L395">      throw new IndexOutOfBoundsException();</span>
    }
<span class="fc" id="L397">    return toIndex - fromIndex;</span>
  }

  /**
   * Throws an {@code IllegalArgumentException} with the specified message and
   * message arguments. The method is still declared to return a value of type
   * {@code &lt;T&gt;} so it can be used as the expression for a {@code return} statement.
   *
   * @param &lt;T&gt; the desired type of the return value
   * @param message the message (pattern)
   * @param msgArgs the message arguments. Note that these are not
   *     {@code printf}-like message arguments. The first message argument within the
   *     message pattern would be {@code ${0}}; the second would be {@code ${1}},
   *     etc. For more information, see &lt;a
   *     href=&quot;../../../module-summary.html#custom-error-messages&quot;&gt;Custom Error
   *     Messages&lt;/a&gt;.
   * @return nothing, but allows {@code fail()} to be used as the expression in a
   *     {@code return} statement
   * @throws IllegalArgumentException always
   */
  public static &lt;T&gt; T fail(String message, Object... msgArgs)
      throws IllegalArgumentException {
<span class="nc" id="L419">    return failOn(DEF_EXC_FACTORY, message, msgArgs);</span>
  }

  /**
   * Throw the exception supplied by the specified {@code Supplier}. The method is
   * still declared to return a value of type {@code &lt;T&gt;} so it can be used as the
   * expression for a {@code return} statement.
   *
   * @param excFactory the supplier of the exception
   * @param &lt;T&gt; the desired type of the return value
   * @param &lt;X&gt; the type of the exception
   * @return nothing, but allows {@code fail()} to be used as the expression in a
   *     {@code return} statement
   * @throws X always
   */
  public static &lt;T, X extends Throwable&gt; T fail(Supplier&lt;X&gt; excFactory) throws X {
<span class="fc" id="L435">    throw excFactory.get();</span>
  }

  /**
   * Throws an exception produced by the specified exception factory with the
   * specified message and message arguments.
   *
   * @param &lt;T&gt; the type of the object that would have been returned if it had
   *     passed the checks
   * @param &lt;X&gt; the type of the exception
   * @param excFactory a function that takes a {@code String} (the exception
   *     message) and produces an {@code Exception}.
   * @param message the message
   * @param msgArgs the message arguments. Note that these are not
   *     {@code printf}-like message arguments. The first message argument within the
   *     message pattern would be {@code ${0}}; the second would be {@code ${1}},
   *     etc. For more information, see &lt;a
   *     href=&quot;../../../module-summary.html#custom-error-messages&quot;&gt;Custom Error
   *     Messages&lt;/a&gt;.
   * @return nothing, but allows {@code fail} to be used as the expression in a
   *     {@code return} statement
   * @throws X always
   */
  public static &lt;T, X extends Throwable&gt; T failOn(
      Function&lt;String, X&gt; excFactory, String message, Object... msgArgs) throws X {
<span class="pc bpc" id="L460" title="1 of 4 branches missed.">    if (msgArgs == null || message == null) {</span>
<span class="fc" id="L461">      throw excFactory.apply(message);</span>
    }
<span class="fc" id="L463">    throw excFactory.apply(formatSimple(message, msgArgs));</span>
  }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>